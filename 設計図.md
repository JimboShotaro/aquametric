# AquaMetric 設計図（進捗メモ）

## 更新（2026-01-01）
- 方針を **Option A（完全オフライン：スマートフォン完結）** に変更（当面サーバー不要）。
- Flutterアプリ骨格 + BLE + Dart解析エンジン + SQLite保存まで実装済み。
- GitHub: https://github.com/JimboShotaro/aquametric

## 現状の実装済み（2026-01-01時点）

### モバイル（Flutter）
- 画面骨格: Dashboard / Sessions / Sync / Settings
- BLE通信: `flutter_blue_plus` v1.32.0 で接続・同期UIの土台

### 解析（Dart / SwimBITベース）
- 48次FIRローパス（3Hz, ハミング窓）
- エネルギーベースの泳法分類（クロール/背泳ぎ/平泳ぎ/バタフライ/休憩）
- ラップ（ターン）検出（加速度マグニチュードの変化）
- メトリクス算出（SWOLF、ペース、ストロークレート、カロリー概算）

### ローカル保存（SQLite）
- `sessions` / `laps` / `sensor_data` テーブルで、セッション・ラップ・生データを端末内に保存
- 解析パイプライン: BLE受信 → バッファ → SQLiteへフラッシュ → セッション終了時に再読込して解析 → 結果保存

## TODO（次にやること / 優先順）
1. UI統合: Dashboard / Session詳細で、SQLiteの実データ（距離/時間/SWOLF/ラップ別泳法など）を表示
2. BLE実データ連携: 腕時計側の送信フォーマット確定（timestamp/acc/gyro）と受信デコードの確定
3. 単体テスト: 解析エンジン（フィルタ・分類・ラップ検出）をサンプルデータで検証
4. 腕時計側実装: 100Hz収集・バッファリング・セッション保存・BLEバッチ送信
5. データエクスポート: CSV/JSONでの出力（オフライン運用のバックアップ用）

## 注記
- 以降の本文は「クラウド/バックエンド前提の将来案」として残している（Option Aで進める間は必須ではない）。

---

AquaMetric: SwimBITアルゴリズムに基づく分散型水泳解析プラットフォームのアーキテクチャ設計と実装詳細報告書1. イントロダクションとプロジェクト定義1.1 プロジェクトの概要と目的本レポートは、SwimBIT（Swimming Biomechanical Inertial Tracking）アルゴリズム  を中核に据えた、高度な水泳解析Webアプリケーション「AquaMetric」の包括的なアーキテクチャ設計書である。本プロジェクトの主たる目的は、学術研究レベルの生体力学解析手法を、一般のアスリートやコーチが日常的に利用可能な商用レベルのSaaS（Software as a Service）へと昇華させることにある。ユーザーの要求に基づき、システムは「ウェアラブルデバイス（腕時計）」、「モバイルゲートウェイ（スマートフォン）」、「クラウド計算コア（バックエンド）」の3層構造で設計される。腕時計側ではリアルタイムのフィードバックとデータ収集に徹し、計算資源の制約が少ないクラウド側でSwimBITの核心である高負荷な信号処理（SVM分類、DTW、エネルギー計算）を実行する「Split-Compute（分散計算）」パラダイムを採用する。これにより、デバイスのバッテリー寿命を最大化しつつ、研究室レベルの解析精度（ストローク判定、ラップ計測、SWOLF効率指標）を担保する。1.2 SwimBITアルゴリズムの理論的要件本システムの設計は、SwimBITの研究論文  で定義された以下の厳密な技術要件に基づいている。これらは「推奨事項」ではなく、システムが正しく機能するための「物理的制約」として扱う。サンプリングレートの厳格性: データのロギングは100 Hzで行われなければならない 。これは10msごとのデータ取得を意味し、水泳中の急速な手の入水衝撃や、フリップターン時の角速度変化を捉えるために不可欠である。Apple Watch等の民生用デバイスにおいて、この高頻度サンプリングとバッテリー寿命のバランスを取ることが最大のエンジニアリング課題となる 2。センサーフュージョン: システムは9軸の慣性データ（3軸加速度、3軸ジャイロスコープ、3軸磁力計）に加え、AHRS（Attitude and Heading Reference System）から導出されるオイラー角（Roll, Pitch, Yaw）を処理する必要がある 。信号処理パイプライン: 生データは、カットオフ周波数3Hzの48次低域通過ハミングフィルタによって前処理され、その後、エネルギー計算に基づくストローク分類器へと送られる 。2. アーキテクチャ概要 (System Architecture)2.1 全体設計思想 (Architectural Philosophy)本システムは「クリーンアーキテクチャ」の原則に従い、ビジネスロジック（SwimBITアルゴリズム）を外部のフレームワーク（UI、DB、デバイスドライバ）から完全に隔離する。これにより、将来的にストローク検知アルゴリズムがSVM（サポートベクターマシン）からDeep Learning（Transformerモデルなど）へ進化したとしても、コアシステムへの影響を最小限に抑えることが可能となる。また、設計にはSOLID原則、特に「単一責任の原則 (SRP)」と「依存関係逆転の原則 (DIP)」を強く意識する。例えば、データソースがApple Watchであるか、Garminであるか、あるいはシミュレーションデータであるかに関わらず、解析エンジンは同一のインターフェース（ISensorSource）を通じてデータを処理する。2.2 システム構成図 (System Diagram)システムは以下の3つの主要ノードで構成される分散システムである。コード スニペット

```mermaid
graph TD
    subgraph "Edge Layer (Wearable)"
        W_App
        W_Buffer
        W_UI
        W_BLE
    end

    subgraph "Gateway Layer (Mobile)"
        M_App
        M_Sync
        M_Cache
        M_Vis
    end

    subgraph "Cloud Core Layer (Backend)"
        LB
        API[FastAPI Gateway]
        Worker
        Logic
        
        DB_TS
        DB_Rel
    end

    W_App -->|100Hz Sampling| W_Buffer
    W_Buffer -->|Batch Transfer (Protobuf)| W_BLE
    W_BLE -.->|Bluetooth (BLE)| M_Sync
    M_Sync --> M_Cache
    M_Cache -->|HTTPS/JSON| API
    API --> LB
    LB --> Worker
    Worker --> Logic
    Logic --> DB_TS
    Logic --> DB_Rel
    Logic -->|Analysis Results| API
    API -->|JSON Response| M_Vis

```
図解解説:Edge Layer: 腕時計は「ダム（Dumb）端末」として振る舞う。複雑な解析は行わず、データの確実な収集とバッファリング、そして時刻表示と簡易的な距離推定のみを行う。Gateway Layer: スマートフォンは、水中では通信不能なBluetoothの制約を補うため、セッション終了後のデータ吸い上げ役（Gateway）として機能する。Cloud Core Layer: Pythonベースの解析エンジンが配置される。100Hzの時系列データは膨大になるため、リレーショナルDBではなく、時系列データに特化したTimescaleDB 4 を採用する。2.3 データフローとシーケンス (Sequence Diagram)ユーザー体験は「計測（水中）」と「解析（陸上）」の2フェーズに明確に分かれる。コード スニペットsequenceDiagram
    autonumber
    participant User as Swimmer
    participant Watch as Wearable App
    participant Phone as Mobile Gateway
    participant Cloud as Python Backend
    participant DB as TimescaleDB

    Note over User, Watch: Phase 1: 水中計測 (Active Session)
    User->>Watch: セッション開始 (Start)
    loop 10msごと (100Hz)
        Watch->>Watch: 加速度・角速度取得
        Watch->>Watch: リングバッファに書き込み
        Watch-->>User: 経過時間・簡易距離表示
    end
    User->>Watch: セッション終了 (Stop & Save)
    Watch->>Watch: ローカルストレージに一時保存

    Note over User, Cloud: Phase 2: 同期と解析 (Sync & Analysis)
    User->>Phone: アプリ起動 (Sync Trigger)
    Phone->>Watch: 未送信データ要求
    Watch->>Phone: バイナリデータ転送 (BLE Batch)
    Phone->>Cloud: POST /api/sessions/upload (Multi-part)
    Cloud->>DB: 生データ保存 (Raw Sensor Data)
    Cloud->>Cloud: 非同期タスクキュー (Celery) 追加
    Cloud-->>Phone: 202 Accepted

    Note over Cloud, DB: Phase 3: SwimBIT解析実行
    Cloud->>DB: 生データ取得
    Cloud->>Cloud: 前処理 (Hamming Filter 3Hz)
    Cloud->>Cloud: セグメンテーション (Turn/Stop検知)
    Cloud->>Cloud: ストローク分類 (Energy/SVM)
    Cloud->>Cloud: 指標算出 (SWOLF, Pace)
    Cloud->>DB: 解析結果保存 (Analyzed Metrics)

    Note over Phone, User: Phase 4: 可視化
    Phone->>Cloud: ポーリング /api/sessions/{id}/status
    Cloud-->>Phone: 解析完了 (Status: Completed)
    Phone->>Cloud: GET /api/sessions/{id}/result
    Cloud-->>Phone: 詳細JSON (Laps, Strokes, Efficiency)
    Phone-->>User: グラフ・カレンダー表示
3. バックエンド詳細設計 (Backend Design - Python)バックエンドは本システムの頭脳であり、学術的な厳密性が求められる領域である。ここではPythonの科学計算スタック（NumPy, SciPy, Pandas）と、高速なAPIフレームワークであるFastAPIを組み合わせる。3.1 クラス設計 (OOP & Domain Modeling)SwimBITの論理構造をそのままクラス階層に落とし込む。拡張性を考慮し、解析アルゴリズムはStrategyパターンを用いて実装する。これにより、将来的に「SwimBIT v2」や、別の論文に基づくアルゴリズムを追加する際も、既存コードを変更せずに済む（Open/Closed原則）。クラス図 (Mermaid Class Diagram)コード スニペットclassDiagram
    %% ドメインモデル
    class SessionData {
        +session_id: UUID
        +user_id: UUID
        +timestamps: np.array
        +accel_data: np.array
        +gyro_data: np.array
        +load_from_db()
    }

    class SwimLap {
        +start_idx: int
        +end_idx: int
        +stroke_type: StrokeType
        +stroke_count: int
        +duration: float
        +swolf: int
    }

    %% インターフェース定義
    class IPreprocessor {
        <<interface>>
        +filter_signal(data: np.array) np.array
    }

    class ISegmenter {
        <<interface>>
        +detect_laps(data: SessionData) List
    }

    class IClassifier {
        <<interface>>
        +classify_stroke(lap_data: np.array) StrokeType
    }

    %% 具体的な実装クラス
    class SwimBITPreprocessor {
        -cutoff_freq: 3Hz
        -order: 48
        +filter_signal(data)
    }

    class PitchRollSegmenter {
        +detect_laps(data)
    }

    class EnergyClassifier {
        +classify_stroke(lap_data)
        -calculate_energy(axis_data)
    }

    class AnalysisPipeline {
        -preprocessor: IPreprocessor
        -segmenter: ISegmenter
        -classifier: IClassifier
        +run(session: SessionData) AnalysisResult
    }

    AnalysisPipeline --> IPreprocessor
    AnalysisPipeline --> ISegmenter
    AnalysisPipeline --> IClassifier
    IPreprocessor <|-- SwimBITPreprocessor
    ISegmenter <|-- PitchRollSegmenter
    IClassifier <|-- EnergyClassifier
    SessionData *-- SwimLap
3.2 コアロジック実装詳細ここでは、SwimBIT論文  の核心部分である「フィルタリング」と「ストローク分類」の実装コードを示す。3.2.1 前処理フィルタ (SwimBITPreprocessor)論文では「48次低域通過ハミングフィルタ、カットオフ周波数3Hz」が指定されている。3Hzという数値は、人間の水泳動作（ストロークサイクル）が通常0.5Hz〜1.5Hz程度であり、それ以上の高周波成分は水流のノイズやセンサーのジッタであると見なせるためである 。Pythonimport numpy as np
from scipy.signal import firwin, lfilter, filtfilt
from abc import ABC, abstractmethod

class IPreprocessor(ABC):
    @abstractmethod
    def process(self, raw_data: np.ndarray, fs: float) -> np.ndarray:
        pass

class SwimBITFilter(IPreprocessor):
    """
    SwimBIT仕様に基づくデジタルフィルタの実装。
    48次FIRフィルタ、Hamming窓、カットオフ3Hz。
    """
    def __init__(self, order: int = 48, cutoff_hz: int = 3):
        self.order = order
        self.cutoff_hz = cutoff_hz

    def process(self, raw_data: np.ndarray, fs: float = 100.0) -> np.ndarray:
        """
        Args:
            raw_data: (N, 3) の加速度またはジャイロデータ
            fs: サンプリング周波数 (Hz)
        Returns:
            フィルタ済みデータ
        """
        nyquist = 0.5 * fs
        normalized_cutoff = self.cutoff_hz / nyquist
        
        # FIRフィルタ係数の設計 (numtaps = order + 1)
        taps = firwin(numtaps=self.order + 1, 
                      cutoff=normalized_cutoff, 
                      window='hamming')
        
        # ゼロ位相フィルタリング (filtfilt) を適用
        # lfilterだと位相遅れが生じるため、往復フィルタリングで位相ズレを解消する
        # Note: 論文では厳密な記述がないが、解析用途ではfiltfiltが標準的
        filtered_data = filtfilt(taps, 1.0, raw_data, axis=0)
        
        return filtered_data
3.2.2 ストローク分類器 (EnergyClassifier)SwimBITの特徴的な手法である「エネルギー計算 ($E_{channel}$)」を実装する。各軸の信号の分散（平均からの偏差の総和）を計算し、その比率によって泳法を決定するヒューリスティックな手法である 。Pythonfrom enum import Enum

class StrokeType(str, Enum):
    FREESTYLE = "freestyle"     # クロール
    BACKSTROKE = "backstroke"   # 背泳ぎ
    BREASTSTROKE = "breaststroke" # 平泳ぎ
    BUTTERFLY = "butterfly"     # バタフライ
    UNKNOWN = "unknown"
    REST = "rest"

class SwimBITEnergyClassifier:
    def classify(self, acc_data: np.ndarray) -> StrokeType:
        """
        1ラップ分の加速度データから泳法を判定する。
        acc_data: (N, 3) -> [x, y, z]
        """
        # エネルギー計算: E = sum(|x[i] - mean|) / N
        means = np.mean(acc_data, axis=0)
        deviations = np.abs(acc_data - means)
        energies = np.sum(deviations, axis=0) / len(acc_data)
        
        E_x, E_y, E_z = energies, energies, energies
        
        # 判定ロジック (論文のヒューリスティックに基づく)
        # Note: 軸の定義はデバイス装着向きに依存する。
        # ここでは X: 指先方向, Y: 手の甲方向, Z: 手のひら垂直方向 と仮定
        
        # 1. Backstroke: 姿勢（重力ベクトル）で判定
        # Z軸の平均加速度が正（手の甲が下）か負（手の甲が上）か
        if means > 5.0: # 重力成分の簡易判定
            return StrokeType.BACKSTROKE
            
        # 2. Freestyle: ロール回転（Y軸）のエネルギーが支配的
        if E_y > E_x and E_y > E_z:
            return StrokeType.FREESTYLE
            
        # 3. Butterfly vs Breaststroke: シンメトリック泳法
        # ButterflyはZ軸（うねり）とX軸（速度変化）のエネルギーが高い
        # Breaststrokeは全体的にエネルギーが低い
        if E_z > E_y:
            # 閾値判定 (定数kはキャリブレーションが必要)
            if E_x > 15.0: 
                return StrokeType.BUTTERFLY
            else:
                return StrokeType.BREASTSTROKE
                
        return StrokeType.UNKNOWN
3.3 API設計とデータモデルフロントエンドとの通信にはRESTful APIを採用し、データ検証にはPydanticを使用する。API エンドポイント定義:MethodEndpointDescriptionRequest BodyResponse ModelPOST/api/v1/sessions/upload生データのアップロードmultipart/form-data (Binary)SessionIDGET/api/v1/sessions/{id}/analysis解析結果の取得-AnalysisResultSchemaGET/api/v1/users/stats/calendarカレンダー用統計取得?start_date=...&end_date=...ListPydanticモデル (schemas.py):Pythonfrom pydantic import BaseModel
from typing import List, Optional
from datetime import datetime

class DailyStat(BaseModel):
    date: str  # YYYY-MM-DD
    total_distance: int
    total_duration_sec: int
    intensity_level: int # 0-4 for heatmap

class LapDetail(BaseModel):
    lap_number: int
    stroke_type: str
    duration: float
    stroke_count: int
    swolf: int
    pace_per_100m: float

class AnalysisResultSchema(BaseModel):
    session_id: str
    processed_at: datetime
    pool_length: int
    total_laps: int
    laps: List
    summary_text: str
4. データベース設計 (Infrastructure & Persistence)4.1 データベース選定理由本システムでは、1回のセッション（1時間）で約360,000レコード（100Hz × 3600秒）のセンサーデータが発生する。通常のリレーショナルデータベース（PostgreSQL単体）では、インデックスの肥大化により書き込み・読み込み速度が劣化する。そのため、PostgreSQLの拡張モジュールであるTimescaleDBを採用する 4。TimescaleDBは「ハイパーテーブル」という概念を用い、自動的にデータを時間ごとのパーティション（チャンク）に分割して保存する。これにより、最新データの書き込み性能を維持しつつ、SQLによる複雑な集計クエリを高速に実行できる 5。4.2 テーブルスキーマ詳細SQL-- 1. セッション管理テーブル (メタデータ)
CREATE TABLE sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    pool_length_m INTEGER DEFAULT 25,
    start_time TIMESTAMPTZ NOT NULL,
    end_time TIMESTAMPTZ,
    status VARCHAR(20) DEFAULT 'processing' -- processing, completed, failed
);

-- 2. 生センサーデータ (Hypertable)
-- 書き込み頻度が極めて高い
CREATE TABLE sensor_readings (
    time TIMESTAMPTZ NOT NULL,
    session_id UUID NOT NULL REFERENCES sessions(id),
    acc_x DOUBLE PRECISION,
    acc_y DOUBLE PRECISION,
    acc_z DOUBLE PRECISION,
    gyro_x DOUBLE PRECISION,
    gyro_y DOUBLE PRECISION,
    gyro_z DOUBLE PRECISION,
    -- 複合主キー推奨 (time, session_id)
    PRIMARY KEY (time, session_id)
);

-- TimescaleDBの有効化 (1日ごとのチャンクに分割)
SELECT create_hypertable('sensor_readings', 'time', chunk_time_interval => INTERVAL '1 day');

-- 3. 解析結果テーブル (ドキュメント指向的利用)
-- ラップごとの詳細はJSONB型で柔軟に保持するか、正規化するか選択可能。
-- ここではクエリ性能を重視し正規化する。
CREATE TABLE detected_laps (
    id SERIAL PRIMARY KEY,
    session_id UUID REFERENCES sessions(id),
    lap_index INTEGER,
    stroke_type VARCHAR(20),
    duration_sec DECIMAL(5, 2),
    stroke_count INTEGER,
    swolf INTEGER,
    avg_pace DECIMAL(5, 2)
);
5. フロントエンド詳細設計 (Frontend Design - TypeScript)フロントエンドは、ユーザーが解析結果を直感的に理解するためのダッシュボードである。技術スタックには**Next.js (React)**を採用し、静的生成（SSG）とサーバーサイドレンダリング（SSR）を使い分ける。5.1 コンポーネント構成とUI設計ユーザーの要望にある「カレンダー記録」と「詳細解析」を実現するため、以下のコンポーネントツリーを設計する。ディレクトリ構成/frontend/src/components/visualizationActivityHeatmap.tsx   # GitHub風カレンダーLapBreakdownTable.tsx # ラップ詳細表BiomechanicsChart.tsx # 姿勢角グラフ (D3.js/Recharts)/formsSessionUploadForm.tsx/hooksuseSwimStats.ts       # データ取得用カスタムフック/pagesdashboard.tsx         # メイン画面session/[id].tsx      # 詳細画面5.2 カレンダー機能の実装 (Activity Heatmap)「カレンダー的に記録」という要件に対し、react-activity-calendar 6 を使用して、日々の泳いだ距離の密度をヒートマップで可視化する。また、詳細表示には react-calendar 7 を用い、クリックした日のトレーニング内容を表示する。実装コード例 (TypeScript):TypeScript// components/visualization/ActivityHeatmap.tsx
import React from 'react';
import ActivityCalendar, { Activity } from 'react-activity-calendar';
import { Tooltip as ReactTooltip } from 'react-tooltip';
import 'react-tooltip/dist/react-tooltip.css';

interface HeatmapProps {
  data: Activity; // { date: "2023-10-01", count: 2500, level: 3 }
}

const SwimHeatmap: React.FC<HeatmapProps> = ({ data }) => {
  return (
    <div className="p-6 bg-white rounded-xl shadow-sm border border-gray-100">
      <h3 className="text-lg font-bold text-gray-800 mb-4">Swimming Consistency</h3>
      <ActivityCalendar
        data={data}
        theme={{
          light: ['#f0fdf4', '#bbf7d0', '#86efac', '#4ade80', '#16a34a'],
          dark: ['#141d1f', '#0e4429', '#006d32', '#26a641', '#39d353'],
        }}
        hideColorLegend={false}
        hideMonthLabels={false}
        renderBlock={(block, activity) => (
          <div
            data-tooltip-id="activity-tooltip"
            data-tooltip-content={`${activity.date}: ${activity.count}m Swam`}
          >
            {block}
          </div>
        )}
      />
      <ReactTooltip id="activity-tooltip" />
    </div>
  );
};

export default SwimHeatmap;
5.3 状態管理と型安全性Redux等の大掛かりな状態管理は避け、React Query (TanStack Query) を使用してサーバー状態のキャッシュと同期を行う。これにより、APIからのデータ取得、ローディング状態、エラーハンドリングを簡潔に記述できる。また、バックエンドのPydanticモデルから生成されたTypeScript型定義（OpenAPI Generator等を使用）を厳密に適用し、Interfaceの不整合によるバグを防ぐ。6. ウェアラブルデバイス設計 (Edge Strategy)6.1 デバイスの役割と制約腕時計側（Apple Watch / WearOS）の実装は、本システムで最も物理的な制約を受ける部分である。サンプリングレート: Apple Watchの CoreMotion フレームワークは100Hzの取得に対応しているが、高負荷である 2。通信: 水中では電波（2.4GHz帯のBluetooth/Wi-Fi）が減衰し、ほぼ通信不能となる。したがって、「ストア＆フォワード（蓄積交換）」方式を採用する。計測中は内部ストレージにデータを溜め込み、水から上がったタイミングでスマートフォンへ一括送信する。6.2 バッテリー最適化戦略100Hzの常時記録はバッテリーを激しく消耗する。以下の戦略で稼働時間を確保する。バッチ処理: センサーイベント毎（10ms毎）に処理を行うのではなく、システムバッファにデータを蓄積し、一定量（例: 500サンプル＝5秒分）溜まった時点でメインメモリへの書き込みを行う。画面更新頻度の低下: 内部ロジックは100Hzで動くが、UI（画面上のタイム表示など）の更新は1Hz（1秒に1回）に抑える。BLE転送の最適化: 生のJSONデータは冗長で転送に時間がかかる（＝バッテリーを食う）。GoogleのProtocol Buffersを用いてバイナリ形式にシリアライズし、ペイロードサイズを約1/3に圧縮して転送する 9。6.3 実装ロジック (疑似コード)Swift// Swift (Apple Watch CoreMotion Example)
import CoreMotion

let motionManager = CMMotionManager()
let queue = OperationQueue()

func startSwimmingSession() {
    guard motionManager.isDeviceMotionAvailable else { return }
    
    // 100Hz = 0.01s
    motionManager.deviceMotionUpdateInterval = 0.01
    
    motionManager.startDeviceMotionUpdates(to: queue) { (data, error) in
        guard let data = data else { return }
        
        // メモリ上のバッファに追加 (UIスレッドをブロックしない)
        self.sensorBuffer.append(SensorData(
            timestamp: data.timestamp,
            acc_x: data.userAcceleration.x,
            acc_y: data.userAcceleration.y,
            acc_z: data.userAcceleration.z,
            //... gyro data
        ))
        
        // バッファが溢れたらファイルへフラッシュ
        if self.sensorBuffer.count >= 1000 {
            self.flushBufferToFile()
        }
    }
}
7. 実装とメンテナンスのポイント (Implementation & Maintenance)7.1 結合度と凝集度ドメインロジックの純粋性: SwimBITFilter や EnergyClassifier といった計算クラスの中に、データベース操作やAPIリクエストのコードを一切含めない。計算クラスは純粋に numpy array を受け取り、結果を返す関数として設計する（純粋関数的アプローチ）。これにより、単体テスト（Unit Test）が容易になり、アルゴリズムの検証がデータベース無しで行えるようになる。7.2 設定ファイルによるチューニングSwimBIT論文には、ストローク判定のための閾値（係数 $k$ など）が登場する。これらをコード内にハードコーディングすると、微調整のたびにデプロイが必要になる。これらは algorithm_config.yaml またはデータベース上の config_table に分離し、実行時にロードする設計とする。YAML# algorithm_config.yaml
filter:
  cutoff_hz: 3.0
  order: 48

classifier:
  thresholds:
    butterfly_x_energy: 15.0
    backstroke_gravity_z: 5.0
  
segmentation:
  min_turn_duration_ms: 1500
7.3 コンテナ化とデプロイNumPyやSciPyはC言語ライブラリに依存するため、環境差異による動作不良が起きやすい。Dockerを使用して実行環境を完全に固定する。Dockerfile# backend/Dockerfile
FROM python:3.10-slim

# 数値計算ライブラリ用のシステム依存関係をインストール
RUN apt-get update && apt-get install -y \
    gcc gfortran libopenblas-dev liblapack-dev

WORKDIR /app
COPY requirements.txt.
RUN pip install --no-cache-dir -r requirements.txt

COPY..
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
8. 結論 (Conclusion)本レポートで提示した「AquaMetric」のアーキテクチャは、SwimBITアルゴリズムの科学的厳密性と、モダンなWebアプリケーションの拡張性を両立させるものである。特に重要な決定事項は以下の3点である：Split-Compute戦略: 腕時計をデータロガー、クラウドを解析エンジンと役割分担することで、100Hz解析という高負荷処理を実用化した。TimescaleDBの採用: IoT特有の大量時系列データの管理問題を解決し、将来的なデータ増大（ペタバイト級）にも耐えうる基盤を構築した。Strategyパターンの適用: 今後、AIモデルが進化した場合でも、システム全体を書き換えることなく、推論エンジン部分のみを差し替え可能な設計とした。この設計図に基づき実装を進めることで、単なる歩数計の延長ではない、真のアスリート向け解析ツールの構築が可能となる。

---

## 9. 開発進捗と実装状況 (Implementation Progress)

### 9.1 実装完了項目 (2024年12月31日時点)

以下のコンポーネントが実装完了済みである：

#### バックエンド (Python/FastAPI)
| モジュール | ファイル | 状態 | 説明 |
|-----------|---------|------|------|
| コア基盤 | `backend/app/main.py` | ✅ 完了 | FastAPI アプリケーションエントリポイント |
| 設定管理 | `backend/config/settings.yaml` | ✅ 完了 | YAML形式の設定ファイル |
| 前処理フィルタ | `backend/app/core/preprocessor.py` | ✅ 完了 | SwimBIT仕様48次FIRフィルタ実装 |
| ストローク分類 | `backend/app/core/classifier.py` | ✅ 完了 | エネルギーベース分類器 |
| ラップ検出 | `backend/app/core/segmenter.py` | ✅ 完了 | Pitch/Roll解析によるターン検出 |
| 解析パイプライン | `backend/app/core/pipeline.py` | ✅ 完了 | Strategyパターンによる統合 |
| APIエンドポイント | `backend/app/api/v1/sessions.py` | ✅ 完了 | セッション管理REST API |
| データモデル | `backend/app/models/` | ✅ 完了 | Pydanticスキーマ定義 |

#### モバイル (Flutter/Dart) - インターフェース定義
| モジュール | ファイル | 状態 | 説明 |
|-----------|---------|------|------|
| APIクライアント | `mobile/lib/core/api/api_client.dart` | ✅ 完了 | バックエンド通信インターフェース |
| BLEマネージャー | `mobile/lib/core/ble/ble_manager.dart` | ✅ 完了 | ウェアラブル通信インターフェース |
| データモデル | `mobile/lib/core/models/` | ✅ 完了 | Dart DTOクラス定義 |

#### ウェアラブル - センサー収集ロジック
| プラットフォーム | ファイル | 状態 | 説明 |
|-----------------|---------|------|------|
| Apple Watch | `wearable/apple-watch/Managers/SensorManager.swift` | ✅ 完了 | CoreMotion 100Hzセンサー収集 |
| WearOS | `wearable/wear-os/managers/SensorManager.kt` | ✅ 完了 | SensorManager 100Hz収集 |
| 共通 | `wearable/proto/sensor_data.proto` | ✅ 完了 | Protobufスキーマ定義 |

#### テスト
| 種別 | ファイル | 状態 | 説明 |
|------|---------|------|------|
| パイプラインテスト | `backend/tests/test_pipeline.py` | ✅ 完了 | 既存SwimBITデータでの動作検証 |

### 9.2 プロジェクト構造

```
aquametric/
├── README.md
├── backend/
│   ├── requirements.txt
│   ├── config/
│   │   └── settings.yaml
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py
│   │   ├── api/
│   │   │   └── v1/
│   │   │       ├── sessions.py
│   │   │       └── users.py
│   │   ├── core/
│   │   │   ├── preprocessor.py
│   │   │   ├── classifier.py
│   │   │   ├── segmenter.py
│   │   │   └── pipeline.py
│   │   ├── models/
│   │   │   ├── domain.py
│   │   │   └── schemas.py
│   │   └── services/
│   │       └── analysis_service.py
│   └── tests/
│       └── test_pipeline.py
├── mobile/
│   └── lib/
│       └── core/
│           ├── api/
│           │   └── api_client.dart
│           ├── ble/
│           │   └── ble_manager.dart
│           └── models/
│               └── swim_models.dart
└── wearable/
    ├── proto/
    │   └── sensor_data.proto
    ├── apple-watch/
    │   └── Managers/
    │       └── SensorManager.swift
    └── wear-os/
        └── managers/
            └── SensorManager.kt
```

---

## 10. 残タスク (TODO List)

### 10.1 優先度: 高 (Phase 1)

| # | タスク | 説明 | 見積工数 |
|---|--------|------|---------|
| 1 | **Flutter UIの実装** | ダッシュボード、セッション詳細、カレンダーヒートマップの画面実装 | 2-3日 |
| 2 | **BLE実機接続テスト** | Apple Watch / WearOSとFlutterアプリ間のBLE通信確認 | 1日 |
| 3 | **TimescaleDB統合** | PostgreSQL + TimescaleDBのセットアップとリポジトリ層実装 | 1日 |
| 4 | **ユーザー認証** | JWT認証の実装（Firebase Auth または独自実装） | 1日 |

### 10.2 優先度: 中 (Phase 2)

| # | タスク | 説明 | 見積工数 |
|---|--------|------|---------|
| 5 | Celery非同期タスク | バックグラウンド解析処理の非同期化 | 0.5日 |
| 6 | Docker Compose | 開発環境の一括起動設定 | 0.5日 |
| 7 | CI/CD | GitHub Actionsによる自動テスト・デプロイ | 0.5日 |
| 8 | Xcode/Android Studioプロジェクト | ウェアラブルアプリのビルド環境構築 | 1日 |

### 10.3 優先度: 低 (Phase 3 - 将来拡張)

| # | タスク | 説明 |
|---|--------|------|
| 9 | MLモデル統合 | SVM/Deep Learning による高精度ストローク判定 |
| 10 | リアルタイム解析 | WebSocket によるライブストリーミング解析 |
| 11 | 多言語対応 | 英語/日本語 i18n |
| 12 | Apple Health / Google Fit 連携 | 外部ヘルスケアプラットフォームとのデータ同期 |

---

## 11. 技術選定の補足: Flutter vs ネイティブ

### 11.1 モバイルアプリ開発の選択肢比較

| 観点 | Flutter (Dart) | Kotlin (Android) | Swift (iOS) |
|------|----------------|------------------|-------------|
| **クロスプラットフォーム** | ✅ 1コードベースでiOS/Android両対応 | ❌ Androidのみ | ❌ iOSのみ |
| **開発速度** | ✅ Hot Reload、単一言語 | △ 標準的 | △ 標準的 |
| **BLEサポート** | ✅ flutter_blue_plus で十分 | ✅ ネイティブAPI | ✅ ネイティブAPI |
| **UIカスタマイズ** | ✅ Material/Cupertino両対応 | ✅ Material Design | ✅ Human Interface |
| **パフォーマンス** | ◯ ほぼネイティブ級 | ✅ 最高 | ✅ 最高 |
| **保守コスト** | ✅ 1チームで済む | ❌ 2チーム必要 | ❌ 2チーム必要 |
| **学習コスト** | ◯ Dart習得必要 | ◯ Kotlin習得 | ◯ Swift習得 |

### 11.2 結論: Flutterを推奨

本プロジェクトにおいては**Flutter**を強く推奨する。理由は以下の通り：

1. **統一コードベース**: iOS/Androidを単一のDartコードで開発でき、保守コストが半減
2. **BLE対応**: `flutter_blue_plus`パッケージで必要なBLE機能（スキャン、接続、データ転送）を完全にカバー
3. **UI一貫性**: Material Design 3 と Cupertino を切り替え可能で、プラットフォーム別の最適なUIを提供
4. **開発効率**: Hot Reload により、UI調整が即座に反映される
5. **既存資産の活用**: 既に`mobile/lib/`にDartインターフェースを定義済み

**注意**: ウェアラブル（Apple Watch / WearOS）はFlutter非対応のため、引き続きSwift/Kotlinでネイティブ開発が必要。

---

## 12. リポジトリ情報

- **GitHub**: https://github.com/JimboShotaro/aquametric
- **ライセンス**: MIT (予定)
- **開発開始日**: 2024年12月31日